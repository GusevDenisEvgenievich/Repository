using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
 
namespace ConsoleApplication11
{
    class Program
    {
        struct Element
        {
            public int Delivery { get; set; }
            public int Value { get; set; }
            public static int FindMinElement(int a, int b)
            {
                if (a > b) return b;
                if (a == b) { return a; }
                else return a;
            }
        }
        
        static void Main(string[] args)
        {
            int i = 0;
            int j = 0;
            Console.Write("Введите количество поставщиков: ");
            int n = Convert.ToInt32(Console.ReadLine());
            int[] a = new int[n];
            Console.Write("Введите количество покупателей: ");
            int m = Convert.ToInt32(Console.ReadLine());
            int[] b = new int[m];
            Element[,] C = new Element[n, m];
            for (i = 0; i < a.Length; i++)
            {
                Console.Write($"Введите количество товара поставщика {i+1}: ");
                a[i] = Convert.ToInt32(Console.ReadLine());
            }
            for (j = 0; j < b.Length; j++)
            {
                Console.Write($"Введите спрос покупателя {j+1}: ");
                b[j] = Convert.ToInt32(Console.ReadLine());
            }
            for (i = 0; i < n; i++)
            {
                for (j = 0; j < m; j++)
                {
                    Console.Write($"Введите цену перевозки от продавца {i} до покупателя {j}: ");
                    C[i, j].Value = Convert.ToInt32(Console.ReadLine());
                }
            }
            
            i = j = 0;
            while (i < n && j < m)
            {
                try
                {
                    if (a[i] == 0) { i++; }
                    if (b[j] == 0) { j++; }
                    if (a[i] == 0 && b[j] == 0) { i++; j++; }
                    C[i, j].Delivery = Element.FindMinElement(a[i], b[j]);
                    a[i] -= C[i, j].Delivery;
                    b[j] -= C[i, j].Delivery;
                }
                catch { }
            }
            
            Console.WriteLine("\nПлан перевозок методом северо-западного угла:");
            i = j = 0;
            for (i = 0; i < n; i++)
            {
                for (j = 0; j < m; j++)
                {
                    Console.Write($"\t{C[i, j].Delivery}");
                }
                Console.WriteLine();
            }
            int ResultCoast = 0;
            for (i = 0; i < n; i++)
            {
                for (j = 0; j < m; j++)
                {
                    ResultCoast += (C[i, j].Value * C[i, j].Delivery);
                }
            }
            Console.WriteLine("Затраты на доставку: {0}", ResultCoast);
            
            
            
            string[] potentialsA = new string[n];
            string[] potentialsB = new string[m];
            int[,] freecells = new int[n,m];
            bool optimal = false;
            
            // Инициализация потенциалов
            for (int q = 0; q < n; q++)
            {
                potentialsA[q] = "";
            }
            for (int w = 0; w < m; w++)
            {
                potentialsB[w] = "";
            }
            
            for (int w = 0; w < n; w++)
            {
                for (int e = 0; e < m; e++)
                {
                    Console.Write($"\t{C[w, e].Delivery}");
                }
                Console.WriteLine();
            }
            Console.WriteLine();
            for (int w = 0; w < n; w++)
            {
                for (int e = 0; e < m; e++)
                {
                    Console.Write($"\t{C[w, e].Value}");
                }
                Console.WriteLine();
            }
            Console.WriteLine();
            for (int e = 0; e < n; e++)
            {
                Console.Write($"\t{potentialsA[e]}");
            }
            Console.WriteLine();
            for (int e = 0; e < m; e++)
            {
                Console.Write($"\t{potentialsB[e]}");
            }
            Console.WriteLine();
            
            // Расчет потенциалов
            for (int w = 0; w < n; w++)
            {
                for (int e = 0; e < m; e++)
                {
                    if (C[w, e].Delivery != 0)
                    {
                        if (potentialsA[w] == "")
                        {
                            if (w == 0 && e == 0)
                            {
                                potentialsA[w] = "0";
                                potentialsB[e] = (C[w, e].Value - int.Parse(potentialsA[w])).ToString();
                            }
                            else
                            {
                                potentialsA[w] = (C[w, e].Value - int.Parse(potentialsB[e])).ToString();
                                Console.WriteLine($"{C[w, e].Value} - {potentialsB[e]} = {potentialsA[w]}   1");
                            }
                        }
                        if (potentialsB[e] == "")
                        {
                            potentialsB[e] = (C[w, e].Value - int.Parse(potentialsA[w])).ToString();
                            Console.WriteLine($"{C[w, e].Value} - {potentialsA[w]} = {potentialsB[e]}   2");
                        }
                    }
                }
            }
            Console.WriteLine("Расчет1");
            
            // Расчет свободных клеток
            for (int w = 0; w < n; w++)
            {
                for (int e = 0; e < m; e++)
                {
                    if (C[w, e].Delivery == 0)
                    {
                        freecells[w,e] = int.Parse(potentialsA[w]) + int.Parse(potentialsB[e]) - C[w, e].Value;
                    }
                }
            }
            Console.WriteLine("Расчет2");
            
            // Вывод потенциалов
            for (int q = 0; q < n; q++)
            {
                Console.Write($"\t{potentialsA[q]}");
            }
            Console.WriteLine();
            for (int w = 0; w < m; w++)
            {
                Console.Write($"\t{potentialsB[w]}");
            }
            Console.WriteLine();
            // Вывод свободных клеток
            for (int q = 0; q < n; q++)
            {
                for (int w = 0; w < m; w++)
                {
                    Console.Write($"\t{freecells[q,w]}");
                }
                Console.WriteLine();
            }
            Console.WriteLine();
            
            /*
            while (!optimal)
            {
                optimal = true;
                // Расчет потенциалов
                for (int w = 0; w < n; w++)
                {
                    for (int e = 0; e < m; e++)
                    {
                        if (C[w, e].Delivery != 0)
                        {
                            if (potentialsA[w] == 0)
                            {
                                potentialsA[w] = C[w, e].Value - potentialsB[e];
                            }
                            else
                            {
                                potentialsB[e] = C[w, e].Value - potentialsA[w];
                            }
                        }
                    }
                }
                Console.WriteLine("Расчет");
                 optimal = false;
                // Проверка условий оптимальности
                for (int w = 0; w < n; w++)
                {
                    for (int e = 0; e < m; e++)
                    {
                        if (C[w, e].Delivery == 0)
                        {
                            if (potentialsA[w] + potentialsB[e] - C[w, e].Value > 0)
                            {
                                optimal = false;
                                // Найти цикл и пересчитать план перевозок
                                // ...
                                for (int r = 0; r < n; r++)
                                {
                                    for (int t = 0; t < m; t++)
                                    {
                                        ResultCoast += (C[r, t].Value * C[r, t].Delivery);
                                    }
                                }
                                Console.WriteLine("Перерасчет");
                            }
                        }
                    }
                }
            }
            */
            // Вывод результатов
            int max=0;
            foreach (int cell in freecells) 
            { 
                if (cell > max) max = cell;
            }
            Console.WriteLine($"Наибольшая оценка {max}");
        }
    }
}